[
  {
    "objectID": "ST558 HW 3 Quarto Doc.html",
    "href": "ST558 HW 3 Quarto Doc.html",
    "title": "Tidyverse Practice",
    "section": "",
    "text": "If your working directory is myfolder/homework/, what relative path would you specify to get the file located at myfolder/Mydata.csv?\n\n\nYou could use the filepath “../Mydata.csv” (the double period indicates going back one level of folders).\n\n\nWhat are the major benefits of using R projects?\n\n\nR Projects allow users to keep all information together in one place, have a common working directory, and also allow for future users to have common file paths.\n\n\nWhat is git and what is github?\n\n\nGit is a version control system. Github is an online repository that uses git.\n\n\nWhat are the two main differences between a tibble and a data.frame?\n\n\nOne major difference is appearance. While data.frame’s print all the raw data (subject to a row/column constraint), tibbles just give a header of data, and also give information directly upon print such as the type of each column, and the number of rows (information that can usually be gleaned from a data.frame with str() or summary()). Another difference is that data.frames don’t remain data.frames upon subsetting, while `tibble s do.\n\n\nRewrite the following nested function call using baseR’s chaining operator:\n\n\nFirst we load in the required packages for the rest of our analysis\n\n\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\nlibrary(DBI)\nlibrary(RSQLite)\nlibrary(Lahman)\nlibrary(readr)\nlibrary(readxl)\n\n\nNext, we untangle the nested function with chaining\n\n\na=arrange(filter(select(as_tibble(iris), starts_with(\"Petal\"), Species), Petal.Length&lt;1.55), Species)\n\nb=iris|&gt;\n  as_tibble() |&gt;\n  select(starts_with(\"Petal\"), Species) |&gt;\n  filter(Petal.Length&lt;1.55) |&gt;\n  arrange(Species)\n\nall.equal(a,b)\n\n[1] TRUE\n\n\n\nWhat is meant by long format data and wide format data? Which do we generally prefer for statistical analysis?\n\n\nLong data format is where each row has one observation and each column is one variable. Wide data formats may have many different observations all on the same row. While wide data formats may be okay for data visualization, for data analysis is it generally preferable to have long data."
  },
  {
    "objectID": "ST558 HW 3 Quarto Doc.html#conceptual-question",
    "href": "ST558 HW 3 Quarto Doc.html#conceptual-question",
    "title": "Tidyverse Practice",
    "section": "",
    "text": "If your working directory is myfolder/homework/, what relative path would you specify to get the file located at myfolder/Mydata.csv?\n\n\nYou could use the filepath “../Mydata.csv” (the double period indicates going back one level of folders).\n\n\nWhat are the major benefits of using R projects?\n\n\nR Projects allow users to keep all information together in one place, have a common working directory, and also allow for future users to have common file paths.\n\n\nWhat is git and what is github?\n\n\nGit is a version control system. Github is an online repository that uses git.\n\n\nWhat are the two main differences between a tibble and a data.frame?\n\n\nOne major difference is appearance. While data.frame’s print all the raw data (subject to a row/column constraint), tibbles just give a header of data, and also give information directly upon print such as the type of each column, and the number of rows (information that can usually be gleaned from a data.frame with str() or summary()). Another difference is that data.frames don’t remain data.frames upon subsetting, while `tibble s do.\n\n\nRewrite the following nested function call using baseR’s chaining operator:\n\n\nFirst we load in the required packages for the rest of our analysis\n\n\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\nlibrary(DBI)\nlibrary(RSQLite)\nlibrary(Lahman)\nlibrary(readr)\nlibrary(readxl)\n\n\nNext, we untangle the nested function with chaining\n\n\na=arrange(filter(select(as_tibble(iris), starts_with(\"Petal\"), Species), Petal.Length&lt;1.55), Species)\n\nb=iris|&gt;\n  as_tibble() |&gt;\n  select(starts_with(\"Petal\"), Species) |&gt;\n  filter(Petal.Length&lt;1.55) |&gt;\n  arrange(Species)\n\nall.equal(a,b)\n\n[1] TRUE\n\n\n\nWhat is meant by long format data and wide format data? Which do we generally prefer for statistical analysis?\n\n\nLong data format is where each row has one observation and each column is one variable. Wide data formats may have many different observations all on the same row. While wide data formats may be okay for data visualization, for data analysis is it generally preferable to have long data."
  },
  {
    "objectID": "ST558 HW 3 Quarto Doc.html#reading-delimited-data",
    "href": "ST558 HW 3 Quarto Doc.html#reading-delimited-data",
    "title": "Tidyverse Practice",
    "section": "Reading Delimited Data",
    "text": "Reading Delimited Data\nWe are given a data source called glass.data from . After inspecting the data, it is clear the format is csv (comma separated values). While we could use read_csv to read in this data to R, a more general method is to use read_delimited, and then specify the delimiter. Both functions come from the tidyverse package.\n\nglass.data=read_delim(\"https://www4.stat.ncsu.edu/~online/datasets/glass.data\", \n  delim=\",\",\n  col_names=c(\"Id\",\"RI\",\"Na\",\"Mg\",\"Al\",\"Si\",\"K\",\"Ca\",\"Ba\",\"Fe\",\"Type_of_glass\"))\n\nRows: 214 Columns: 11\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\ndbl (11): Id, RI, Na, Mg, Al, Si, K, Ca, Ba, Fe, Type_of_glass\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\nglass.data\n\n# A tibble: 214 × 11\n      Id    RI    Na    Mg    Al    Si     K    Ca    Ba    Fe Type_of_glass\n   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;         &lt;dbl&gt;\n 1     1  1.52  13.6  4.49  1.1   71.8  0.06  8.75     0  0                1\n 2     2  1.52  13.9  3.6   1.36  72.7  0.48  7.83     0  0                1\n 3     3  1.52  13.5  3.55  1.54  73.0  0.39  7.78     0  0                1\n 4     4  1.52  13.2  3.69  1.29  72.6  0.57  8.22     0  0                1\n 5     5  1.52  13.3  3.62  1.24  73.1  0.55  8.07     0  0                1\n 6     6  1.52  12.8  3.61  1.62  73.0  0.64  8.07     0  0.26             1\n 7     7  1.52  13.3  3.6   1.14  73.1  0.58  8.17     0  0                1\n 8     8  1.52  13.2  3.61  1.05  73.2  0.57  8.24     0  0                1\n 9     9  1.52  14.0  3.58  1.37  72.1  0.56  8.3      0  0                1\n10    10  1.52  13    3.6   1.36  73.0  0.57  8.4      0  0.11             1\n# ℹ 204 more rows\n\n\nWe now want to manipulate the data. The below chunk first creates a vector of names, and then relabels numeric data based on the position in this vector. We finish our study of the glass tibble by only showing cases where the Fe variable is less than 0.2, and when the type of glass is either tableware or headlamps.\n\nrename=c(\"building_windows_float_processed\",\n         \"building_windows_non_float_processed\",\n         \"vehicle_windows_float_processed\",\n         \"vehicle_windows_non_float_processed\",\n         \"containers\",\n         \"tableware\",\n         \"headlamps\")\n\nglass=glass.data |&gt;\n  mutate(Type_of_glass=ifelse(Type_of_glass==1, rename[1],\n                       ifelse(Type_of_glass==2, rename[2],\n                       ifelse(Type_of_glass==3, rename[3],\n                       ifelse(Type_of_glass==4, rename[4],\n                       ifelse(Type_of_glass==5, rename[5],\n                       ifelse(Type_of_glass==6, rename[6],\n                       ifelse(Type_of_glass==7, rename[7],\n                       \"N/A\")))))))) |&gt;\n  filter(Fe&lt;0.2 & (Type_of_glass==\"tableware\" | Type_of_glass==\"headlamps\"))\nglass\n\n# A tibble: 38 × 11\n      Id    RI    Na    Mg    Al    Si     K    Ca    Ba    Fe Type_of_glass\n   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;        \n 1   177  1.52  14    2.39  1.56  72.4  0     9.57  0        0 tableware    \n 2   178  1.52  13.8  2.41  1.19  72.8  0     9.77  0        0 tableware    \n 3   179  1.52  14.5  2.24  1.62  72.4  0     9.26  0        0 tableware    \n 4   180  1.52  14.1  2.19  1.66  72.7  0     9.32  0        0 tableware    \n 5   181  1.51  14.4  1.74  1.54  74.6  0     7.59  0        0 tableware    \n 6   182  1.52  15.0  0.78  1.74  72.5  0     9.95  0        0 tableware    \n 7   183  1.52  14.2  0     2.09  72.7  0    10.9   0        0 tableware    \n 8   184  1.52  14.6  0     0.56  73.5  0    11.2   0        0 tableware    \n 9   185  1.51  17.4  0     0.34  75.4  0     6.65  0        0 tableware    \n10   186  1.51  13.7  3.2   1.81  72.8  1.76  5.43  1.19     0 headlamps    \n# ℹ 28 more rows\n\n\nWe are now told to load in yeast.data. Unlike the glass.data, upon inspection, this data is delimited with a double space. We can load it into R using a similar method as above.\n\nyeast.data=read_delim(\"https://www4.stat.ncsu.edu/~online/datasets/yeast.data\",\n                      delim=\"  \",\n                      col_names=c(\"seq_name\",\"mcg\", \"gvh\", \n                                  \"alm\", \"mit\",\"erl\",\"pox\",\n                                  \"vac\",\"nuc\",\"class\"))\n\nWarning: One or more parsing issues, call `problems()` on your data frame for details,\ne.g.:\n  dat &lt;- vroom(...)\n  problems(dat)\n\n\nRows: 1484 Columns: 10\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \"  \"\nchr (2): seq_name, class\ndbl (8): mcg, gvh, alm, mit, erl, pox, vac, nuc\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\nyeast.data\n\n# A tibble: 1,484 × 10\n   seq_name     mcg   gvh   alm   mit   erl   pox   vac   nuc class\n   &lt;chr&gt;      &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;\n 1 ADT1_YEAST  0.58  0.61  0.47  0.13   0.5   0    0.48  0.22 MIT  \n 2 ADT2_YEAST  0.43  0.67  0.48  0.27   0.5   0    0.53  0.22 MIT  \n 3 ADT3_YEAST  0.64  0.62  0.49  0.15   0.5   0    0.53  0.22 MIT  \n 4 AAR2_YEAST  0.58  0.44  0.57  0.13   0.5   0    0.54  0.22 NUC  \n 5 AATM_YEAST  0.42  0.44  0.48  0.54   0.5   0    0.48  0.22 MIT  \n 6 AATC_YEAST  0.51  0.4   0.56  0.17   0.5   0.5  0.49  0.22 CYT  \n 7 ABC1_YEAST  0.5   0.54  0.48  0.65   0.5   0    0.53  0.22 MIT  \n 8 BAF1_YEAST  0.48  0.45  0.59  0.2    0.5   0    0.58  0.34 NUC  \n 9 ABF2_YEAST  0.55  0.5   0.66  0.36   0.5   0    0.49  0.22 MIT  \n10 ABP1_YEAST  0.4   0.39  0.6   0.15   0.5   0    0.58  0.3  CYT  \n# ℹ 1,474 more rows\n\n\nAgain we want to manipulate the data. This time we remove the variables seq_name and nuc, and then compute the mean and median of each numeric variable, contingent on the class.\n\nyeast=yeast.data |&gt;\n  select(-c(seq_name, nuc)) |&gt;\n  group_by(class) |&gt;\n  mutate(across(where(is.numeric), list(mean=mean, median=median), .names=\"{.col}_{.fn}\"))\nyeast\n\n# A tibble: 1,484 × 22\n# Groups:   class [44]\n     mcg   gvh   alm   mit   erl   pox   vac class mcg_mean mcg_median gvh_mean\n   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;    &lt;dbl&gt;      &lt;dbl&gt;    &lt;dbl&gt;\n 1  0.58  0.61  0.47  0.13   0.5   0    0.48 MIT      0.521       0.51    0.531\n 2  0.43  0.67  0.48  0.27   0.5   0    0.53 MIT      0.521       0.51    0.531\n 3  0.64  0.62  0.49  0.15   0.5   0    0.53 MIT      0.521       0.51    0.531\n 4  0.58  0.44  0.57  0.13   0.5   0    0.54 NUC      0.453       0.45    0.458\n 5  0.42  0.44  0.48  0.54   0.5   0    0.48 MIT      0.521       0.51    0.531\n 6  0.51  0.4   0.56  0.17   0.5   0.5  0.49 CYT      0.480       0.48    0.469\n 7  0.5   0.54  0.48  0.65   0.5   0    0.53 MIT      0.521       0.51    0.531\n 8  0.48  0.45  0.59  0.2    0.5   0    0.58 NUC      0.453       0.45    0.458\n 9  0.55  0.5   0.66  0.36   0.5   0    0.49 MIT      0.521       0.51    0.531\n10  0.4   0.39  0.6   0.15   0.5   0    0.58 CYT      0.480       0.48    0.469\n# ℹ 1,474 more rows\n# ℹ 11 more variables: gvh_median &lt;dbl&gt;, alm_mean &lt;dbl&gt;, alm_median &lt;dbl&gt;,\n#   mit_mean &lt;dbl&gt;, mit_median &lt;dbl&gt;, erl_mean &lt;dbl&gt;, erl_median &lt;dbl&gt;,\n#   pox_mean &lt;dbl&gt;, pox_median &lt;dbl&gt;, vac_mean &lt;dbl&gt;, vac_median &lt;dbl&gt;"
  },
  {
    "objectID": "ST558 HW 3 Quarto Doc.html#combining-excel-and-delimited-data",
    "href": "ST558 HW 3 Quarto Doc.html#combining-excel-and-delimited-data",
    "title": "Tidyverse Practice",
    "section": "Combining Excel And Delimited Data",
    "text": "Combining Excel And Delimited Data\nWe are now interested in data on white wine. After downloading the data source into our projects’ working directory, we can directly access the file with the read_excel function from the readxl package. Like the above, we want to make some small modifications. Since our data source is an excel workbook with two different sheets, we load the first sheet, and use the data on the second sheet to name the columns in the first sheet. Also, we add a column to specify that the wine is white.\n\nexcel_sheets(\"./white-wine.xlsx\")\n\n[1] \"white-wine\" \"variables\" \n\nwhite_wine=read_excel(\"./white-wine.xlsx\",\n              sheet=\"white-wine\")\nwhite_wine\n\n# A tibble: 4,898 × 12\n   `fixed acidity` `volatile acidity` `citric acid` `residual sugar` chlorides\n             &lt;dbl&gt;              &lt;dbl&gt;         &lt;dbl&gt;            &lt;dbl&gt;     &lt;dbl&gt;\n 1               7               0.27          0.36             20.7     0.045\n 2              63               0.3           0.34              1.6     0.049\n 3              81               0.28          0.4               6.9     0.05 \n 4              72               0.23          0.32              8.5     0.058\n 5              72               0.23          0.32              8.5     0.058\n 6              81               0.28          0.4               6.9     0.05 \n 7              62               0.32          0.16              7       0.045\n 8               7               0.27          0.36             20.7     0.045\n 9              63               0.3           0.34              1.6     0.049\n10              81               0.22          0.43              1.5     0.044\n# ℹ 4,888 more rows\n# ℹ 7 more variables: `free sulfur dioxide` &lt;dbl&gt;,\n#   `total sulfur dioxide` &lt;dbl&gt;, density &lt;dbl&gt;, pH &lt;dbl&gt;, sulphates &lt;dbl&gt;,\n#   alcohol &lt;dbl&gt;, quality &lt;dbl&gt;\n\nvariables=as.data.frame(\n              read_excel(\"./white-wine.xlsx\",\n              sheet=\"variables\"))\nvariables\n\n              Variables\n1         fixed_acidity\n2      volatile_acidity\n3           citric_acid\n4        residual_sugar\n5             chlorides\n6   free_sulfur_dioxide\n7  total_sulfur_dioxide\n8               density\n9                    pH\n10            sulphates\n11              alcohol\n12              quality\n\ncolnames(white_wine)=variables$Variables\nwhite_wine=mutate(white_wine, wine_type=rep(\"white\", nrow(white_wine)))\nwhite_wine\n\n# A tibble: 4,898 × 13\n   fixed_acidity volatile_acidity citric_acid residual_sugar chlorides\n           &lt;dbl&gt;            &lt;dbl&gt;       &lt;dbl&gt;          &lt;dbl&gt;     &lt;dbl&gt;\n 1             7             0.27        0.36           20.7     0.045\n 2            63             0.3         0.34            1.6     0.049\n 3            81             0.28        0.4             6.9     0.05 \n 4            72             0.23        0.32            8.5     0.058\n 5            72             0.23        0.32            8.5     0.058\n 6            81             0.28        0.4             6.9     0.05 \n 7            62             0.32        0.16            7       0.045\n 8             7             0.27        0.36           20.7     0.045\n 9            63             0.3         0.34            1.6     0.049\n10            81             0.22        0.43            1.5     0.044\n# ℹ 4,888 more rows\n# ℹ 8 more variables: free_sulfur_dioxide &lt;dbl&gt;, total_sulfur_dioxide &lt;dbl&gt;,\n#   density &lt;dbl&gt;, pH &lt;dbl&gt;, sulphates &lt;dbl&gt;, alcohol &lt;dbl&gt;, quality &lt;dbl&gt;,\n#   wine_type &lt;chr&gt;\n\n\nWe also have data on red wine. We again download the data source into our projects’ working directory, though this data is delimited with semi-colons. Luckily the readr package has a nice function to deal with this format, namely read_csv2. To make sure the red and white wine data sets both have the same format, we rename the columns like the above, force all columns to numeric data, and add a column specifying the wine type as red.\n\nred_wine=read_csv2(\"./red-wine.csv\",col_types=\"n\")  \n\nℹ Using \"','\" as decimal and \"'.'\" as grouping mark. Use `read_delim()` for more control.\n\n\nWarning: One or more parsing issues, call `problems()` on your data frame for details,\ne.g.:\n  dat &lt;- vroom(...)\n  problems(dat)\n\ncolnames(red_wine)=variables$Variables\nred_wine= red_wine |&gt;\n  mutate_all(as.numeric)\nred_wine= mutate(red_wine, wine_type=rep(\"red\", nrow(red_wine)))\n\nWe now combine the white and red wine data sets into one tibble, filter the data to only look at high-quality wines with a reasonable alcohol content, and sort the tibble by the quality of the wine. We also select only certain variables, and then add columns for the mean and standard deviation of the alcohol content, contingent on the classification of quality.\n\nwine=bind_rows(white_wine, red_wine)  \n\nwine=wine |&gt;\n  filter(quality&gt;6.5 & alcohol&lt;132) |&gt;\n  arrange(desc(quality)) |&gt;\n  select(contains(\"acid\"), c(\"alcohol\", \"wine_type\", \"quality\")) |&gt;\n  group_by(quality) |&gt;\n  mutate(across(alcohol, list(mean=mean, sd=sd), .names=\"{.col}_{.fn}\"))\nwine\n\n# A tibble: 1,198 × 8\n# Groups:   quality [3]\n   fixed_acidity volatile_acidity citric_acid alcohol wine_type quality\n           &lt;dbl&gt;            &lt;dbl&gt;       &lt;dbl&gt;   &lt;dbl&gt; &lt;chr&gt;       &lt;dbl&gt;\n 1            91             0.27        0.45     104 white           9\n 2            66             0.36        0.29     124 white           9\n 3            74             0.24        0.36     125 white           9\n 4            69             0.36        0.34     127 white           9\n 5            71             0.26        0.49     129 white           9\n 6            62             0.66        0.48     128 white           8\n 7            62             0.66        0.48     128 white           8\n 8            68             0.26        0.42     105 white           8\n 9            67             0.23        0.31     107 white           8\n10            67             0.23        0.31     107 white           8\n# ℹ 1,188 more rows\n# ℹ 2 more variables: alcohol_mean &lt;dbl&gt;, alcohol_sd &lt;dbl&gt;"
  },
  {
    "objectID": "ST558 HW 3 Quarto Doc.html#relational-database-practice",
    "href": "ST558 HW 3 Quarto Doc.html#relational-database-practice",
    "title": "Tidyverse Practice",
    "section": "Relational Database Practice",
    "text": "Relational Database Practice\nWe know move on to relational databases, after loading in Sean Lahman’s baseball database. One of our first tasks is to return Hall Of Famer’s along with their year of induction and the category they were inducted for.\n\ncon=dbConnect(RSQLite::SQLite(), \"lahman.db\")\ndbListTables(con)\n\n [1] \"AllstarFull\"         \"Appearances\"         \"AwardsManagers\"     \n [4] \"AwardsPlayers\"       \"AwardsShareManagers\" \"AwardsSharePlayers\" \n [7] \"Batting\"             \"BattingPost\"         \"CollegePlaying\"     \n[10] \"Fielding\"            \"FieldingOF\"          \"FieldingOFsplit\"    \n[13] \"FieldingPost\"        \"HallOfFame\"          \"HomeGames\"          \n[16] \"LahmanData\"          \"Managers\"            \"ManagersHalf\"       \n[19] \"Parks\"               \"People\"              \"Pitching\"           \n[22] \"PitchingPost\"        \"Salaries\"            \"Schools\"            \n[25] \"SeriesPost\"          \"Teams\"               \"TeamsFranchises\"    \n[28] \"TeamsHalf\"           \"battingLabels\"       \"fieldingLabels\"     \n[31] \"pitchingLabels\"     \n\ntbl(con, \"Teams\")\n\n# Source:   table&lt;`Teams`&gt; [?? x 48]\n# Database: sqlite 3.46.0 [C:\\Users\\LiamFlaherty\\Documents\\ST558-HW-3\\lahman.db]\n   yearID lgID  teamID franchID divID  Rank     G Ghome     W     L DivWin WCWin\n    &lt;int&gt; &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt;    &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt;  &lt;chr&gt;\n 1   1871 NA    BS1    BNA      &lt;NA&gt;      3    31    NA    20    10 &lt;NA&gt;   &lt;NA&gt; \n 2   1871 NA    CH1    CNA      &lt;NA&gt;      2    28    NA    19     9 &lt;NA&gt;   &lt;NA&gt; \n 3   1871 NA    CL1    CFC      &lt;NA&gt;      8    29    NA    10    19 &lt;NA&gt;   &lt;NA&gt; \n 4   1871 NA    FW1    KEK      &lt;NA&gt;      7    19    NA     7    12 &lt;NA&gt;   &lt;NA&gt; \n 5   1871 NA    NY2    NNA      &lt;NA&gt;      5    33    NA    16    17 &lt;NA&gt;   &lt;NA&gt; \n 6   1871 NA    PH1    PNA      &lt;NA&gt;      1    28    NA    21     7 &lt;NA&gt;   &lt;NA&gt; \n 7   1871 NA    RC1    ROK      &lt;NA&gt;      9    25    NA     4    21 &lt;NA&gt;   &lt;NA&gt; \n 8   1871 NA    TRO    TRO      &lt;NA&gt;      6    29    NA    13    15 &lt;NA&gt;   &lt;NA&gt; \n 9   1871 NA    WS3    OLY      &lt;NA&gt;      4    32    NA    15    15 &lt;NA&gt;   &lt;NA&gt; \n10   1872 NA    BL1    BLC      &lt;NA&gt;      2    58    NA    35    19 &lt;NA&gt;   &lt;NA&gt; \n# ℹ more rows\n# ℹ 36 more variables: LgWin &lt;chr&gt;, WSWin &lt;chr&gt;, R &lt;int&gt;, AB &lt;int&gt;, H &lt;int&gt;,\n#   X2B &lt;int&gt;, X3B &lt;int&gt;, HR &lt;int&gt;, BB &lt;int&gt;, SO &lt;int&gt;, SB &lt;int&gt;, CS &lt;int&gt;,\n#   HBP &lt;int&gt;, SF &lt;int&gt;, RA &lt;int&gt;, ER &lt;int&gt;, ERA &lt;dbl&gt;, CG &lt;int&gt;, SHO &lt;int&gt;,\n#   SV &lt;int&gt;, IPouts &lt;int&gt;, HA &lt;int&gt;, HRA &lt;int&gt;, BBA &lt;int&gt;, SOA &lt;int&gt;, E &lt;int&gt;,\n#   DP &lt;int&gt;, FP &lt;dbl&gt;, name &lt;chr&gt;, park &lt;chr&gt;, attendance &lt;int&gt;, BPF &lt;int&gt;,\n#   PPF &lt;int&gt;, teamIDBR &lt;chr&gt;, teamIDlahman45 &lt;chr&gt;, teamIDretro &lt;chr&gt;\n\nhof=tbl(con, \"HallofFame\") |&gt;\n  filter(inducted==\"Y\") |&gt;\n  select(c(\"playerID\", \"yearID\", \"category\"))\n\nThis is some great information, but lacks some meaningful information, perhaps most importantly the players/coaches/umpires/etc. actual name! We can add this information by joining tables as shown below.\n\nnamed_hof=right_join(tbl(con, \"People\") ,hof) |&gt;\n  select(c(\"playerID\", \"nameFirst\", \"nameLast\", \"yearID\", \"category\"))\n\nJoining with `by = join_by(playerID)`\n\nnamed_hof=as_tibble(named_hof)\nnamed_hof\n\n# A tibble: 340 × 5\n   playerID  nameFirst nameLast  yearID category\n   &lt;chr&gt;     &lt;chr&gt;     &lt;chr&gt;      &lt;int&gt; &lt;chr&gt;   \n 1 aaronha01 Hank      Aaron       1982 Player  \n 2 alexape01 Pete      Alexander   1938 Player  \n 3 alomaro01 Roberto   Alomar      2011 Player  \n 4 alstowa01 Walter    Alston      1983 Manager \n 5 andersp01 Sparky    Anderson    2000 Manager \n 6 ansonca01 Cap       Anson       1939 Player  \n 7 aparilu01 Luis      Aparicio    1984 Player  \n 8 applilu01 Luke      Appling     1964 Player  \n 9 ashburi01 Richie    Ashburn     1995 Player  \n10 averiea01 Earl      Averill     1975 Player  \n# ℹ 330 more rows\n\n\nNow we turn our attention to the managers. We first filter down the dataframe, then compute their winning percentage, then sort the result.\n\nmanagers=tbl(con, \"Managers\")\n\nmanagers=managers |&gt;\n  select(\"playerID\", \"G\", \"W\", \"L\") |&gt;\n  group_by(playerID) |&gt;\n  summarize(G_managed=sum(G, na.rm=TRUE),\n            Total_W=sum(W, na.rm=TRUE),\n            Total_L=sum(L, na.rm=TRUE)) |&gt;\n  collect()\n\n  Total_WP=managers$Total_W/managers$G_managed\n  managers=bind_cols(managers, Total_WP=Total_WP) |&gt;\n    arrange(desc(Total_WP))\n  managers\n\n# A tibble: 749 × 5\n   playerID  G_managed Total_W Total_L Total_WP\n   &lt;chr&gt;         &lt;int&gt;   &lt;int&gt;   &lt;int&gt;    &lt;dbl&gt;\n 1 bensove01         1       1       0        1\n 2 burwebi01         1       1       0        1\n 3 cohenan01         1       1       0        1\n 4 ebeldi99          3       3       0        1\n 5 falkbi01          1       1       0        1\n 6 hardeme01         3       3       0        1\n 7 simmote01         1       1       0        1\n 8 steinte01         2       2       0        1\n 9 sukefcl01         2       2       0        1\n10 tamarjo01         1       1       0        1\n# ℹ 739 more rows\n\n\nFinally, we look at all the people in the hall of fame who have ever managed a game.\n\nmanager_hof=left_join(managers, named_hof, by=\"playerID\")\nmanager_hof\n\n# A tibble: 749 × 9\n   playerID  G_managed Total_W Total_L Total_WP nameFirst nameLast yearID\n   &lt;chr&gt;         &lt;int&gt;   &lt;int&gt;   &lt;int&gt;    &lt;dbl&gt; &lt;chr&gt;     &lt;chr&gt;     &lt;int&gt;\n 1 bensove01         1       1       0        1 &lt;NA&gt;      &lt;NA&gt;         NA\n 2 burwebi01         1       1       0        1 &lt;NA&gt;      &lt;NA&gt;         NA\n 3 cohenan01         1       1       0        1 &lt;NA&gt;      &lt;NA&gt;         NA\n 4 ebeldi99          3       3       0        1 &lt;NA&gt;      &lt;NA&gt;         NA\n 5 falkbi01          1       1       0        1 &lt;NA&gt;      &lt;NA&gt;         NA\n 6 hardeme01         3       3       0        1 &lt;NA&gt;      &lt;NA&gt;         NA\n 7 simmote01         1       1       0        1 Ted       Simmons    2020\n 8 steinte01         2       2       0        1 &lt;NA&gt;      &lt;NA&gt;         NA\n 9 sukefcl01         2       2       0        1 &lt;NA&gt;      &lt;NA&gt;         NA\n10 tamarjo01         1       1       0        1 &lt;NA&gt;      &lt;NA&gt;         NA\n# ℹ 739 more rows\n# ℹ 1 more variable: category &lt;chr&gt;"
  }
]