[
  {
    "objectID": "ST558 HW 3 Quarto Doc.html",
    "href": "ST558 HW 3 Quarto Doc.html",
    "title": "Tidyverse Practice",
    "section": "",
    "text": "If your working directory is myfolder/homework/, what relative path would you specify to get the file located at myfolder/Mydata.csv?\n\n\nYou could use the filepath “../Mydata.csv” (the double period indicates going back one level of folders).\n\n\nWhat are the major benefits of using R projects?\n\n\nR Projects allow users to keep all information together in one place, have a common working directory, and also allow for future users to have common file paths.\n\n\nWhat is git and what is github?\n\n\nGit is a version control system. Github is an online repository that uses git.\n\n\nWhat are the two main differences between a tibble and a data.frame?\n\n\nOne major difference is appearance. While data.frame’s print all the raw data (subject to a row/column constraint), tibbles just give a header of data, and also give information directly upon print such as the type of each column, and the number of rows (information that can usually be gleaned from a data.frame with str() or summary()). Another difference is that data.frames don’t remain data.frames upon subsetting, while `tibble s do.\n\n\nRewrite the following nested function call using baseR’s chaining operator:\n\n\nFirst we load in the required packages for the rest of our analysis\n\n\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\nlibrary(DBI)\nlibrary(RSQLite)\nlibrary(Lahman)\nlibrary(readr)\nlibrary(readxl)\n\n\nNext, we untangle the nested function with chaining\n\n\na=arrange(filter(select(as_tibble(iris), starts_with(\"Petal\"), Species), Petal.Length&lt;1.55), Species)\n\nb=iris|&gt;\n  as_tibble() |&gt;\n  select(starts_with(\"Petal\"), Species) |&gt;\n  filter(Petal.Length&lt;1.55) |&gt;\n  arrange(Species)\n\nall.equal(a,b)\n\n[1] TRUE\n\n\n\nWhat is meant by long format data and wide format data? Which do we generally prefer for statistical analysis?\n\n\nLong data format is where each row has one observation and each column is one variable. Wide data formats may have many different observations all on the same row. While wide data formats may be okay for data visualization, for data analysis is it generally preferable to have long data."
  },
  {
    "objectID": "ST558 HW 3 Quarto Doc.html#conceptual-question",
    "href": "ST558 HW 3 Quarto Doc.html#conceptual-question",
    "title": "Tidyverse Practice",
    "section": "",
    "text": "If your working directory is myfolder/homework/, what relative path would you specify to get the file located at myfolder/Mydata.csv?\n\n\nYou could use the filepath “../Mydata.csv” (the double period indicates going back one level of folders).\n\n\nWhat are the major benefits of using R projects?\n\n\nR Projects allow users to keep all information together in one place, have a common working directory, and also allow for future users to have common file paths.\n\n\nWhat is git and what is github?\n\n\nGit is a version control system. Github is an online repository that uses git.\n\n\nWhat are the two main differences between a tibble and a data.frame?\n\n\nOne major difference is appearance. While data.frame’s print all the raw data (subject to a row/column constraint), tibbles just give a header of data, and also give information directly upon print such as the type of each column, and the number of rows (information that can usually be gleaned from a data.frame with str() or summary()). Another difference is that data.frames don’t remain data.frames upon subsetting, while `tibble s do.\n\n\nRewrite the following nested function call using baseR’s chaining operator:\n\n\nFirst we load in the required packages for the rest of our analysis\n\n\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\nlibrary(DBI)\nlibrary(RSQLite)\nlibrary(Lahman)\nlibrary(readr)\nlibrary(readxl)\n\n\nNext, we untangle the nested function with chaining\n\n\na=arrange(filter(select(as_tibble(iris), starts_with(\"Petal\"), Species), Petal.Length&lt;1.55), Species)\n\nb=iris|&gt;\n  as_tibble() |&gt;\n  select(starts_with(\"Petal\"), Species) |&gt;\n  filter(Petal.Length&lt;1.55) |&gt;\n  arrange(Species)\n\nall.equal(a,b)\n\n[1] TRUE\n\n\n\nWhat is meant by long format data and wide format data? Which do we generally prefer for statistical analysis?\n\n\nLong data format is where each row has one observation and each column is one variable. Wide data formats may have many different observations all on the same row. While wide data formats may be okay for data visualization, for data analysis is it generally preferable to have long data."
  },
  {
    "objectID": "ST558 HW 3 Quarto Doc.html#reading-delimited-data",
    "href": "ST558 HW 3 Quarto Doc.html#reading-delimited-data",
    "title": "Tidyverse Practice",
    "section": "Reading Delimited Data",
    "text": "Reading Delimited Data\nWe are given a data source called glass.data from . After inspecting the data, it is clear the format is csv (comma separated values). While we could use read_csv to read in this data to R, a more general method is to use read_delimited, and then specify the delimiter. Both functions come from the tidyverse package.\n\nglass.data=read_delim(\"https://www4.stat.ncsu.edu/~online/datasets/glass.data\", \n  delim=\",\",\n  col_names=c(\"Id\",\"RI\",\"Na\",\"Mg\",\"Al\",\"Si\",\"K\",\"Ca\",\"Ba\",\"Fe\",\"Type_of_glass\"))\n\nRows: 214 Columns: 11\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\ndbl (11): Id, RI, Na, Mg, Al, Si, K, Ca, Ba, Fe, Type_of_glass\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\nglass.data\n\n# A tibble: 214 × 11\n      Id    RI    Na    Mg    Al    Si     K    Ca    Ba    Fe Type_of_glass\n   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;         &lt;dbl&gt;\n 1     1  1.52  13.6  4.49  1.1   71.8  0.06  8.75     0  0                1\n 2     2  1.52  13.9  3.6   1.36  72.7  0.48  7.83     0  0                1\n 3     3  1.52  13.5  3.55  1.54  73.0  0.39  7.78     0  0                1\n 4     4  1.52  13.2  3.69  1.29  72.6  0.57  8.22     0  0                1\n 5     5  1.52  13.3  3.62  1.24  73.1  0.55  8.07     0  0                1\n 6     6  1.52  12.8  3.61  1.62  73.0  0.64  8.07     0  0.26             1\n 7     7  1.52  13.3  3.6   1.14  73.1  0.58  8.17     0  0                1\n 8     8  1.52  13.2  3.61  1.05  73.2  0.57  8.24     0  0                1\n 9     9  1.52  14.0  3.58  1.37  72.1  0.56  8.3      0  0                1\n10    10  1.52  13    3.6   1.36  73.0  0.57  8.4      0  0.11             1\n# ℹ 204 more rows\n\n\nWe now want to manipulate the data. The below chunk first creates a vector of names, and then relabels numeric data based on the position in this vector. We finish our study of the glass tibble by only showing cases where the Fe variable is less than 0.2, and when the type of glass is either tableware or headlamps.\n\nrename=c(\"building_windows_float_processed\",\n         \"building_windows_non_float_processed\",\n         \"vehicle_windows_float_processed\",\n         \"vehicle_windows_non_float_processed\",\n         \"containers\",\n         \"tableware\",\n         \"headlamps\")\n\nglass=glass.data |&gt;\n  mutate(Type_of_glass=ifelse(Type_of_glass==1, rename[1],\n                       ifelse(Type_of_glass==2, rename[2],\n                       ifelse(Type_of_glass==3, rename[3],\n                       ifelse(Type_of_glass==4, rename[4],\n                       ifelse(Type_of_glass==5, rename[5],\n                       ifelse(Type_of_glass==6, rename[6],\n                       ifelse(Type_of_glass==7, rename[7],\n                       \"N/A\")))))))) |&gt;\n  filter(Fe&lt;0.2 & (Type_of_glass==\"tableware\" | Type_of_glass==\"headlamps\"))\nglass\n\n# A tibble: 38 × 11\n      Id    RI    Na    Mg    Al    Si     K    Ca    Ba    Fe Type_of_glass\n   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;        \n 1   177  1.52  14    2.39  1.56  72.4  0     9.57  0        0 tableware    \n 2   178  1.52  13.8  2.41  1.19  72.8  0     9.77  0        0 tableware    \n 3   179  1.52  14.5  2.24  1.62  72.4  0     9.26  0        0 tableware    \n 4   180  1.52  14.1  2.19  1.66  72.7  0     9.32  0        0 tableware    \n 5   181  1.51  14.4  1.74  1.54  74.6  0     7.59  0        0 tableware    \n 6   182  1.52  15.0  0.78  1.74  72.5  0     9.95  0        0 tableware    \n 7   183  1.52  14.2  0     2.09  72.7  0    10.9   0        0 tableware    \n 8   184  1.52  14.6  0     0.56  73.5  0    11.2   0        0 tableware    \n 9   185  1.51  17.4  0     0.34  75.4  0     6.65  0        0 tableware    \n10   186  1.51  13.7  3.2   1.81  72.8  1.76  5.43  1.19     0 headlamps    \n# ℹ 28 more rows\n\n\nWe are now told to load in yeast.data. Unlike the glass.data, upon inspection, this data is delimited with a double space. We can load it into R using a similar method as above.\n\nyeast.data=read_delim(\"https://www4.stat.ncsu.edu/~online/datasets/yeast.data\",\n                      delim=\"  \",\n                      col_names=c(\"seq_name\",\"mcg\", \"gvh\", \n                                  \"alm\", \"mit\",\"erl\",\"pox\",\n                                  \"vac\",\"nuc\",\"class\"))\n\nWarning: One or more parsing issues, call `problems()` on your data frame for details,\ne.g.:\n  dat &lt;- vroom(...)\n  problems(dat)\n\n\nRows: 1484 Columns: 10\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \"  \"\nchr (2): seq_name, class\ndbl (8): mcg, gvh, alm, mit, erl, pox, vac, nuc\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\nyeast.data\n\n# A tibble: 1,484 × 10\n   seq_name     mcg   gvh   alm   mit   erl   pox   vac   nuc class\n   &lt;chr&gt;      &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;\n 1 ADT1_YEAST  0.58  0.61  0.47  0.13   0.5   0    0.48  0.22 MIT  \n 2 ADT2_YEAST  0.43  0.67  0.48  0.27   0.5   0    0.53  0.22 MIT  \n 3 ADT3_YEAST  0.64  0.62  0.49  0.15   0.5   0    0.53  0.22 MIT  \n 4 AAR2_YEAST  0.58  0.44  0.57  0.13   0.5   0    0.54  0.22 NUC  \n 5 AATM_YEAST  0.42  0.44  0.48  0.54   0.5   0    0.48  0.22 MIT  \n 6 AATC_YEAST  0.51  0.4   0.56  0.17   0.5   0.5  0.49  0.22 CYT  \n 7 ABC1_YEAST  0.5   0.54  0.48  0.65   0.5   0    0.53  0.22 MIT  \n 8 BAF1_YEAST  0.48  0.45  0.59  0.2    0.5   0    0.58  0.34 NUC  \n 9 ABF2_YEAST  0.55  0.5   0.66  0.36   0.5   0    0.49  0.22 MIT  \n10 ABP1_YEAST  0.4   0.39  0.6   0.15   0.5   0    0.58  0.3  CYT  \n# ℹ 1,474 more rows\n\n\nAgain we want to manipulate the data. This time we remove the variables seq_name and nuc, and then compute the mean and median of each numeric variable, contingent on the class.\n\nyeast=yeast.data |&gt;\n  select(-c(seq_name, nuc)) |&gt;\n  group_by(class) |&gt;\n  mutate(across(where(is.numeric), list(mean=mean, median=median), .names=\"{.col}_{.fn}\"))\nyeast\n\n# A tibble: 1,484 × 22\n# Groups:   class [44]\n     mcg   gvh   alm   mit   erl   pox   vac class mcg_mean mcg_median gvh_mean\n   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;    &lt;dbl&gt;      &lt;dbl&gt;    &lt;dbl&gt;\n 1  0.58  0.61  0.47  0.13   0.5   0    0.48 MIT      0.521       0.51    0.531\n 2  0.43  0.67  0.48  0.27   0.5   0    0.53 MIT      0.521       0.51    0.531\n 3  0.64  0.62  0.49  0.15   0.5   0    0.53 MIT      0.521       0.51    0.531\n 4  0.58  0.44  0.57  0.13   0.5   0    0.54 NUC      0.453       0.45    0.458\n 5  0.42  0.44  0.48  0.54   0.5   0    0.48 MIT      0.521       0.51    0.531\n 6  0.51  0.4   0.56  0.17   0.5   0.5  0.49 CYT      0.480       0.48    0.469\n 7  0.5   0.54  0.48  0.65   0.5   0    0.53 MIT      0.521       0.51    0.531\n 8  0.48  0.45  0.59  0.2    0.5   0    0.58 NUC      0.453       0.45    0.458\n 9  0.55  0.5   0.66  0.36   0.5   0    0.49 MIT      0.521       0.51    0.531\n10  0.4   0.39  0.6   0.15   0.5   0    0.58 CYT      0.480       0.48    0.469\n# ℹ 1,474 more rows\n# ℹ 11 more variables: gvh_median &lt;dbl&gt;, alm_mean &lt;dbl&gt;, alm_median &lt;dbl&gt;,\n#   mit_mean &lt;dbl&gt;, mit_median &lt;dbl&gt;, erl_mean &lt;dbl&gt;, erl_median &lt;dbl&gt;,\n#   pox_mean &lt;dbl&gt;, pox_median &lt;dbl&gt;, vac_mean &lt;dbl&gt;, vac_median &lt;dbl&gt;"
  },
  {
    "objectID": "ST558 HW 3 Quarto Doc.html#combining-excel-and-delimited-data",
    "href": "ST558 HW 3 Quarto Doc.html#combining-excel-and-delimited-data",
    "title": "Tidyverse Practice",
    "section": "Combining Excel And Delimited Data",
    "text": "Combining Excel And Delimited Data\nWe are now interested in data on white wine. After downloading the data source into our projects’ working directory, we can directly access the file with the read_excel function from the readxl package. Like the above, we want to make some small modifications. Since our data source is an excel workbook with two different sheets, we load the first sheet, and use the data on the second sheet to name the columns in the first sheet. Also, we add a column to specify that the wine is white.\n\nexcel_sheets(\"./white-wine.xlsx\")\n\n[1] \"white-wine\" \"variables\" \n\nwhite_wine=read_excel(\"./white-wine.xlsx\",\n              sheet=\"white-wine\")\nwhite_wine\n\n# A tibble: 4,898 × 12\n   `fixed acidity` `volatile acidity` `citric acid` `residual sugar` chlorides\n             &lt;dbl&gt;              &lt;dbl&gt;         &lt;dbl&gt;            &lt;dbl&gt;     &lt;dbl&gt;\n 1               7               0.27          0.36             20.7     0.045\n 2              63               0.3           0.34              1.6     0.049\n 3              81               0.28          0.4               6.9     0.05 \n 4              72               0.23          0.32              8.5     0.058\n 5              72               0.23          0.32              8.5     0.058\n 6              81               0.28          0.4               6.9     0.05 \n 7              62               0.32          0.16              7       0.045\n 8               7               0.27          0.36             20.7     0.045\n 9              63               0.3           0.34              1.6     0.049\n10              81               0.22          0.43              1.5     0.044\n# ℹ 4,888 more rows\n# ℹ 7 more variables: `free sulfur dioxide` &lt;dbl&gt;,\n#   `total sulfur dioxide` &lt;dbl&gt;, density &lt;dbl&gt;, pH &lt;dbl&gt;, sulphates &lt;dbl&gt;,\n#   alcohol &lt;dbl&gt;, quality &lt;dbl&gt;\n\nvariables=as.data.frame(\n              read_excel(\"./white-wine.xlsx\",\n              sheet=\"variables\"))\nvariables\n\n              Variables\n1         fixed_acidity\n2      volatile_acidity\n3           citric_acid\n4        residual_sugar\n5             chlorides\n6   free_sulfur_dioxide\n7  total_sulfur_dioxide\n8               density\n9                    pH\n10            sulphates\n11              alcohol\n12              quality\n\ncolnames(white_wine)=variables$Variables\nwhite_wine=mutate(white_wine, wine_type=rep(\"white\", nrow(white_wine)))\nwhite_wine\n\n# A tibble: 4,898 × 13\n   fixed_acidity volatile_acidity citric_acid residual_sugar chlorides\n           &lt;dbl&gt;            &lt;dbl&gt;       &lt;dbl&gt;          &lt;dbl&gt;     &lt;dbl&gt;\n 1             7             0.27        0.36           20.7     0.045\n 2            63             0.3         0.34            1.6     0.049\n 3            81             0.28        0.4             6.9     0.05 \n 4            72             0.23        0.32            8.5     0.058\n 5            72             0.23        0.32            8.5     0.058\n 6            81             0.28        0.4             6.9     0.05 \n 7            62             0.32        0.16            7       0.045\n 8             7             0.27        0.36           20.7     0.045\n 9            63             0.3         0.34            1.6     0.049\n10            81             0.22        0.43            1.5     0.044\n# ℹ 4,888 more rows\n# ℹ 8 more variables: free_sulfur_dioxide &lt;dbl&gt;, total_sulfur_dioxide &lt;dbl&gt;,\n#   density &lt;dbl&gt;, pH &lt;dbl&gt;, sulphates &lt;dbl&gt;, alcohol &lt;dbl&gt;, quality &lt;dbl&gt;,\n#   wine_type &lt;chr&gt;\n\n\nWe also have data on red wine. We again download the data source into our projects’ working directory, though this data is delimited with semi-colons. Luckily the readr package has a nice function to deal with this format, namely read_csv2. To make sure the red and white wine data sets both have the same format, we rename the columns like the above, force all columns to numeric data, and add a column specifying the wine type as red.\n\nred_wine=read_csv2(\"./red-wine.csv\",col_types=\"n\")  \n\nℹ Using \"','\" as decimal and \"'.'\" as grouping mark. Use `read_delim()` for more control.\n\n\nWarning: One or more parsing issues, call `problems()` on your data frame for details,\ne.g.:\n  dat &lt;- vroom(...)\n  problems(dat)\n\ncolnames(red_wine)=variables$Variables\nred_wine= red_wine |&gt;\n  mutate_all(as.numeric)\nred_wine= mutate(red_wine, wine_type=rep(\"red\", nrow(red_wine)))\n\nWe now combine the white and red wine data sets into one tibble, filter the data to only look at high-quality wines with a reasonable alcohol content, and sort the tibble by the quality of the wine. We also select only certain variables, and then add columns for the mean and standard deviation of the alcohol content, contingent on the classification of quality.\n\nwine=bind_rows(white_wine, red_wine)  \n\nwine=wine |&gt;\n  filter(quality&gt;6.5 & alcohol&lt;132) |&gt;\n  arrange(desc(quality)) |&gt;\n  select(contains(\"acid\"), c(\"alcohol\", \"wine_type\", \"quality\")) |&gt;\n  group_by(quality) |&gt;\n  mutate(across(alcohol, list(mean=mean, sd=sd), .names=\"{.col}_{.fn}\"))\nwine\n\n# A tibble: 1,198 × 8\n# Groups:   quality [3]\n   fixed_acidity volatile_acidity citric_acid alcohol wine_type quality\n           &lt;dbl&gt;            &lt;dbl&gt;       &lt;dbl&gt;   &lt;dbl&gt; &lt;chr&gt;       &lt;dbl&gt;\n 1            91             0.27        0.45     104 white           9\n 2            66             0.36        0.29     124 white           9\n 3            74             0.24        0.36     125 white           9\n 4            69             0.36        0.34     127 white           9\n 5            71             0.26        0.49     129 white           9\n 6            62             0.66        0.48     128 white           8\n 7            62             0.66        0.48     128 white           8\n 8            68             0.26        0.42     105 white           8\n 9            67             0.23        0.31     107 white           8\n10            67             0.23        0.31     107 white           8\n# ℹ 1,188 more rows\n# ℹ 2 more variables: alcohol_mean &lt;dbl&gt;, alcohol_sd &lt;dbl&gt;"
  }
]